#  [390. 消除游戏](https://leetcode.cn/problems/elimination-game/)

## 题意



## 题解

(找规律)

题解：这道题其实是变种的约瑟夫循环问题。

我们用 f(n) 代表将 1 - n 先从左到右再从右到左遍历最后剩下来的数字

用 b(n) 代表将 1 - n 先从右到左，再从左到右遍历最后剩下来的数字。

我们可以发现其中一些规律：

- f(1) = 1, b(1) = 1

- f(n) = 2 * b(n/2)

- f(n) + b(n) = n + 1

规则1很好理解，是初始状态

规则2是因为，假设初始数组是[1,2,3,4,5,6]，最终剩下来的数字是f(6)，经过第一轮从左到右遍历后剩下来的是[2,4,6]，恰好是2 * [1,2,3]，但是这时候我们开始要从右侧开始遍历了，最终剩下来的数字是b(3)，我们可以发现f(6)=2*b(3)。如果初始数组长度为奇数也可以得到一样的结果。

规则3是因为，假设f(n)最终留下来的是从左到右的第k个数字，那么b(n)和f(n)是对称的操作，那么最后剩下来的肯定是从右到左的第k个数字，在这一题中二者相加之和是n+1。


有了上面三个定理，答案就很好求解了，把公式3代入公式2可以得到：


f(n) = 2 \* b(n/2) = 2 \* (n / 2 + 1 − f(n/2)) 


```c++
class Solution {
public:
    // 变种约瑟夫环
    int lastRemaining(int n) {
        if (n == 1) return 1;
        return 2 * (n / 2 + 1 - lastRemaining(n / 2));
    }
};
```



```python3

```

