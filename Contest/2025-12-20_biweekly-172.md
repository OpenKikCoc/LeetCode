# 第 172 场双周赛

链接: https://leetcode.cn/contest/biweekly-contest-172/

---

### [3779. Minimum Number of Operations to Have Distinct Elements](https://leetcode.cn/problems/minimum-number-of-operations-to-have-distinct-elements/)

实际上不用二分，从右边找第一个重复数字位置即可...

```c++
class Solution {
public:
    const static int N = 1e5 + 10;
    
    vector<int> ns;
    int n;
    bool st[N];
    
    bool check(int x) {
        memset(st, 0, sizeof st);
        for (int i = x; i < n; ++ i )
            if (st[ns[i]])
                return false;
            else
                st[ns[i]] = true;
        return true;
    }
    
    int minOperations(vector<int>& nums) {
        this->ns = nums;
        this->n = ns.size();
        
        int l = 0, r = n;
        while (l < r) {
            int mid = l + r >> 1;
            if (check(mid))
                r = mid;
            else
                l = mid + 1;
        }

        if (l == 0)
            return 0;

        // 题意理解有问题
        // [如果剩余元素少于三个，则移除 所有 剩余元素] 指的不是最后连带移除...
        return (l + 2) / 3;
    }
};
```

### [3780. Maximum Sum of Three Numbers Divisible by Three](https://leetcode.cn/problems/maximum-sum-of-three-numbers-divisible-by-three/)

```c++
class Solution {
public:
    int maximumSum(vector<int>& nums) {
        vector<int> xs[3];
        for (auto x : nums)
            xs[x % 3].push_back(x);

        for (int i = 0; i < 3; ++ i )
            sort(xs[i].begin(), xs[i].end());
        int n0 = xs[0].size(), n1 = xs[1].size(), n2 = xs[2].size();

        int res = 0;
        // 分情况讨论
        {
            // 1. 0 + 0 + 0
            if (n0 >= 3)
                res = max(res, xs[0][n0 - 1] + xs[0][n0 - 2] + xs[0][n0 - 3]);
        }
        {
            // 2. 0 + 1 + 2
            if (n0 && n1 && n2)
                res = max(res, xs[0].back() + xs[1].back() + xs[2].back());
        }
        {
            // 3. 1 + 1 + 1
            if (n1 >= 3)
                res = max(res, xs[1][n1 - 1] + xs[1][n1 - 2] + xs[1][n1 - 3]);
        }
        {
            // 4. 2 + 2 + 2
            if (n2 >= 3)
                res = max(res, xs[2][n2 - 1] + xs[2][n2 - 2] + xs[2][n2 - 3]);
        }
        return res;
    }
};
```

### [3781. Maximum Score After Binary Swaps](https://leetcode.cn/problems/maximum-score-after-binary-swaps/)

从左侧扫描也行，代码实现简单些，用大顶堆维护遇到一个 1 就消耗堆顶

```c++
class Solution {
public:
    // 题意相当于 字符中的1可以向左侧移动
    //  显然 从右向左扫描 变扫描边维护
    //  对于某个位置i 如果右侧还有没有被使用的1 或者右侧已经被用的1不如当前 则可以交换
    using LL = long long;
    
    long long maximumScore(vector<int>& nums, string s) {
        int n = nums.size();

        LL res = 0;
        priority_queue<int, vector<int>, greater<int>> heap; // 维护小顶堆
        for (int i = n - 1, one = 0; i >= 0; -- i ) {
            if (s[i] == '1')
                one ++ ;
            int x = nums[i];
            if (one) {
                heap.push(x);
                one -- , res += x;
            } else {
                if (heap.size() && x > heap.top()) {
                    int y = heap.top();
                    heap.pop(); res -= y;
                    heap.push(x); res += x;
                }
            }
        }
        return res;
    }
};
```

### [3782. Last Remaining Integer After Alternating Deletion Operations](https://leetcode.cn/problems/last-remaining-integer-after-alternating-deletion-operations/) [TAG]

约瑟夫环变种

```c++
class Solution {
public:
    // 同 390. 消除游戏 https://leetcode.cn/problems/elimination-game/
    // 考虑约瑟夫环变种
    //
    // 用 f(n) 表示将 [1,n] 从左到右遍历最后剩下来的数字
    // 用 b(n) 表示将 [1,n] 从右到左遍历最后剩下来的数字
    //
    // 对于 [1, 2, 3, 4, 5, 6, 7, 8]
    // n = 8
    //      f(n) = [1, 3, 5, 7] => [3, 7] => [3]
    //      b(n) = [2, 4, 6, 8] => [2, 6] => [6]
    // 对于 [1, 2, 3, 4, 5, 6, 7]
    // n = 7
    //      f(n) = [1, 3, 5, 7] => [3, 7] => [3] ---> [1,2,3,4]*2-1 => b((n+1)/2)*2-1
    //      b(n) = [1, 3, 5, 7] => [1, 5] => [1]
    //
    // 对于 [1, 2, 3, 4]
    // n = 4
    //      f(n) = [1, 3] => [3]
    //      b(n) = [2, 4] => [2]
    // 对于 [1, 2, 3]
    // n = 3
    //      f(n) = [1, 3] => [3]
    //      b(n) = [1, 3] => [1]
    
    // 则
    //  f(1) = 1, b(1) = 1
    //  f(n) + b(n) = n + 1 永远成立 => b(n) = n + 1 - f(n)
    //  if n % 2 == 0
    //     f(n) = f(n - 1)
    //  else
    //     f(n) = b((n+1)/2)*2-1 带入前面恒成立的式子
    //          = (n+1) + 2 - f((n+1)/2) - 1
    //          = n + 2 - f((n+1)/2)
    long long lastInteger(long long n) {
        if (n == 1)
            return 1;
        if (n & 1)
            return n + 2 - 2 * lastInteger((n + 1) / 2);
        return lastInteger(n - 1);
    }
};
```
