# 第 480 场周赛

链接: https://leetcode.cn/contest/weekly-contest-480/

---

> virtual rank: 175/1772

### [3774. Absolute Difference Between Maximum and Minimum K Elements](https://leetcode.cn/problems/absolute-difference-between-maximum-and-minimum-k-elements/)

```c++
class Solution {
public:
    int absDifference(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        int n = nums.size();
        int a = 0, b = 0;
        for (int i = 0, j = n - k; i < k; ++ i , ++ j )
            a += nums[i], b += nums[j];
        return b - a;
    }
};
```

### [3775. Reverse Words With Same Vowel Count](https://leetcode.cn/problems/reverse-words-with-same-vowel-count/)

```c++
class Solution {
public:
    bool check(char c) {
        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';
    }
    
    string reverseWords(string s) {
        int n = s.size(), cnt = -1;
        for (int i = 0; i < n; ++ i ) {
            int j = i, c = 0;
            while (j < n && isalpha(s[j]))
                c += check(s[j ++ ]);

            if (cnt == -1)
                cnt = c;
            else if (c == cnt)
                for (int x = i, y = j - 1; x < y; ++ x , -- y )
                    swap(s[x], s[y]);
            i = j;
        }
        return s;
    }
};
```

### [3776. Minimum Moves to Balance Circular Array](https://leetcode.cn/problems/minimum-moves-to-balance-circular-array/)

取模的话其实也可以不用追加原属组

```c++
class Solution {
public:
    using LL = long long;
    
    long long minMoves(vector<int>& balance) {
        int n = balance.size(), p = -1;
        LL sum = 0;
        for (int i = 0; i < n; ++ i ) {
            sum += balance[i];
            if (balance[i] < 0)
                p = i;
        }
        if (p == -1)
            return 0;
        if (sum < 0)
            return -1;

        // 处理环形数组
        for (int i = 0; i < n; ++ i )
            balance.push_back(balance[i]);
        for (int i = 0; i < n; ++ i )
            balance.push_back(balance[i]);

        p = p + n;

        LL res = 0, need = -balance[p];
        for (int w = 1; w <= n / 2; ++ w ) {
            int l = (p - w) % n, r = (p + w) % n;
            LL tot = 0;
            if (l >= 0)
                tot += balance[l], balance[l] = 0;
            if (r < n)
                tot += balance[r], balance[r] = 0;
            LL use = min(need, tot);
            need -= use;
            res += use * w;
            if (need <= 0)
                break;
        }
        return res;
    }
};
```

### [3777. Minimum Deletions to Make Alternating Substring](https://leetcode.cn/problems/minimum-deletions-to-make-alternating-substring/)

pushup 函数用到了 `l` & `r` 如果不清理会干扰计算

也可以用 BIT，理清楚细节，翻转时只影响相邻两个位置即可

```c++
class Solution {
public:
    // 考虑查询操作 遍历肯定不行 复杂度O(n^2)会爆
    // 显然连续不同的是一个区间 每次修改单点会引发区间变化
    // 给定查询 这个区间内的连续段
    // => 可以珂朵莉树，但是这个东西适合区间修改，单点可以直接简化用线段树
    //
    // 'A' = 0, 'B' = 1
    // 考虑线段树节点维护的信息
    // l, r, w总数 开头是0的最小代价 开头是1的最小改动代价
    //
    // 但是题目求的是 删除代价... 改下pushup即可

    const static int N = 1e5 + 10;

    struct Node {
        int l, r;
        int s0, s1;
    } tr[N << 2];
    void pushup(Node & u, Node & l, Node & r) {
        u.l = l.l, u.r = r.r;   // ATTENTION
        u.s0 = u.s1 = 0;
        int w = l.r - l.l + 1;
        u.s0 = l.s0 + ((w - l.s0) & 1 ? r.s1 : r.s0);
        u.s1 = l.s1 + ((w - l.s1) & 1 ? r.s0 : r.s1);
    }
    void pushup(int u) {
        pushup(tr[u], tr[u << 1], tr[u << 1 | 1]);
    }

    string s;

    void build(int u, int l, int r) {
        if (l == r) {
            tr[u] = {l, r, 0, 0};
            tr[u].s0 = s[l] == 'B', tr[u].s1 = s[l] == 'A';
        } else {
            tr[u] = {l, r};
            int mid = l + r >> 1;
            build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
            pushup(u);
        }
    }
    void modify(int u, int x) {
        if (tr[u].l == x && tr[u].r == x)
            swap(tr[u].s0, tr[u].s1);
        else {
            int mid = tr[u].l + tr[u].r >> 1;
            if (x <= mid)
                modify(u << 1, x);
            else
                modify(u << 1 | 1, x);
            pushup(u);
        }
    }
    Node query(int u, int l, int r) {
        if (tr[u].l >= l && tr[u].r <= r)
            return tr[u];
        else {
            int mid = tr[u].l + tr[u].r >> 1;
            if (r <= mid)
                return query(u << 1, l, r);
            else if (l > mid)
                return query(u << 1 | 1, l, r);
            Node ret;
            auto left = query(u << 1, l, r);
            auto right = query(u << 1 | 1, l, r);
            pushup(ret, left, right);
            return ret;
        }
    }
    
    
    vector<int> minDeletions(string s, vector<vector<int>>& queries) {
        this->s = s;
        build(1, 0, s.size() - 1);

        vector<int> res;
        for (auto & q : queries) {
            if (q[0] == 1)
                modify(1, q[1]);
            else {
                auto ret = query(1, q[1], q[2]);
                res.push_back(min(ret.s0, ret.s1));
            }
        }
        return res;
    }
};
```
