# 第 479 场周赛

链接: https://leetcode.cn/contest/weekly-contest-479/

---

### [3769. Sort Integers by Binary Reflection](https://leetcode.cn/problems/sort-integers-by-binary-reflection/)

```c++
class Solution {
public:
    using PII = pair<int, int>;

    int get(int x) {
        int ret = 0;
        while (x) {
            ret <<= 1;
            ret |= x & 1;
            x >>= 1;
        }
        return ret;
    }
    
    vector<int> sortByReflection(vector<int>& nums) {
        vector<PII> xs;
        for (auto x : nums)
            xs.push_back({get(x), x});
        sort(xs.begin(), xs.end());
        vector<int> res;
        for (auto & [a, b] : xs)
            res.push_back(b);
        return res;
    }
};
```

### [3770. Largest Prime from Consecutive Prime Sum](https://leetcode.cn/problems/largest-prime-from-consecutive-prime-sum/)

```c++
const static int N = 5e5 + 10;

vector<int> primes;
bool st[N];

void init() {
    if (primes.size())
        return;
    memset(st, 0, sizeof st);
    for (int i = 2; i < N; ++ i ) {
        if (!st[i])
            primes.push_back(i);
        for (int j = 0; primes[j] <= (N - 1) / i/*ATTENTION 不能是N/i 会计算出错少算*/; ++ j ) {
            st[i * primes[j]] = true;
            if (i % primes[j] == 0)
                break;
        }
    }
}

class Solution {
public:
    // 显然有定理 质数一定是由更小的质数加和而来
    int largestPrime(int n) {
        init();
        
        int len = primes.size(), res = 0;
        for (int i = 0, s = 0; i < len && n; ++ i ) {
            int p = primes[i];
            if (p > n)
                break;
            n -= p, s += p;
            if (s < N && !st[s]) // 也必须是质数
                res = s;
        }
        return res;
    }
};
```

### [3771. Total Score of Dungeon Runs](https://leetcode.cn/problems/total-score-of-dungeon-runs/)

BIT 是标准写法，对于本题 damage 非负数，还可以按 `贡献法` 结合二分去算，略

```c++
class Solution {
public:
    // 能拿分意味着 hp-d[i]>r[i]的数量
    // 从第一个位置开始 到位置i
    //   hp - sum{d[i]} >= r[i]
    //   hp >= sum{d[i]} + r[i] => 显然可以维护下d前缀和
    // 如果变换为从第二个位置开始 到位置i
    //   hp >= sum{d[i]-d[0]} + r[i]
    // or hp + d[0] >= sum{d[i]} + r[i]
    //
    // 考虑维护sum{d[i]}+r[i]的值域 则题目等同于算有多少个更小的数字
    const static int N = 1e5 + 10; // ATTENTION 数组访问越界WA1
    using LL = long long;

    int n;
    vector<LL> dr, xs;

    int get(LL x) {
        return lower_bound(xs.begin(), xs.end(), x) - xs.begin();
    }

    int tr[N];
    void init() {
        memset(tr, 0, sizeof tr);
    }
    int lowbit(int x) {
        return x & -x;
    }
    void add(int x, int y) {
        for (int i = x; i < N; i += lowbit(i))
            tr[i] += y;
    }
    int sum(int x) {
        int ret = 0;
        for (int i = x; i; i -= lowbit(i))
            ret += tr[i];
        return ret;
    }
    
    long long totalScore(int hp, vector<int>& damage, vector<int>& requirement) {
        this->n = damage.size();
        LL s = 0;
        for (int i = 0; i < n; ++ i ) {
            s += damage[i];
            dr.push_back(s + requirement[i]);
        }

        xs = dr;
        sort(xs.begin(), xs.end());
        xs.erase(unique(xs.begin(), xs.end()), xs.end());

        init();
        for (int i = 0; i < n; ++ i )
            add(get(dr[i]) + 1, 1); // ATTENTION 下标偏移1

        LL res = 0, nhp = hp;
        for (int i = 0; i < n; ++ i ) {
            int idx = get(nhp);
            if (idx < xs.size() && xs[idx] > nhp)
                idx = idx;
            else
                idx ++ ; // ATTENTION 可能导致数组访问越界
            res += sum(idx);
            nhp += damage[i];
            add(get(dr[i]) + 1, -1);
        }
        return res;
    }
};
```

### [3772. Maximum Subgraph Score in a Tree](https://leetcode.cn/problems/maximum-subgraph-score-in-a-tree/)

显然换根，理清楚计算细节，加快速度

```c++
class Solution {
public:
    // [每个节点包含改及诶单的连通子图的最大得分] => 显然要换根
    // 分数为 好节点-坏节点 连通子图的意义在于 如果分数为负 这部分负的可以不要
    const static int N = 1e5 + 10, M = 2e5 + 10;

    int h[N], e[M], ne[M], idx;
    void init() {
        memset(h, -1, sizeof h);
        idx = 0;
    }
    void add(int a, int b) {
        e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
    }

    int f[N], g[N];
    vector<int> v;

    void dfs_d(int u, int pa) {
        f[u] += v[u];
        for (int i = h[u]; ~i; i = ne[i]) {
            int j = e[i];
            if (j == pa)
                continue;
            dfs_d(j, u);
            // 记录 包含当前节点的 往下的最大得分
            f[u] += max(0, f[j]);
        }
    }
    void dfs_u(int u, int pa) {
        g[u] += v[u]; // ATTENTION += 初始化
        for (int i = h[u]; ~i; i = ne[i]) {
            int j = e[i];
            if (j == pa)
                continue;

            // // ATTENTION delta 需要统计其他子树的增量
            // int delta = max({
            //     0,
            //     f[u] - max(0, f[j]),
            //     g[u],
            //     g[u] - v[u] + f[u] - max(0, f[j]),
            // });
            // if (delta/*ATTEINTION not g[u] but delta*/ < 0)
            //     g[j] = g[j]; // unchanged
            // else
            //     g[j] += delta;

            // 简化
            g[j] += max(0, g[u] - v[u] + f[u] - max(0, f[j]));

            dfs_u(j, u);
        }
    }
    
    vector<int> maxSubgraphScore(int n, vector<vector<int>>& edges, vector<int>& good) {
        init();
        for (auto & e : edges)
            add(e[0], e[1]), add(e[1], e[0]);

        memset(f, 0, sizeof f), memset(g, 0, sizeof g);
        v.clear();
        for (int i = 0; i < n; ++ i )
            v.push_back(good[i] ? 1 : -1);

        dfs_d(0, -1);
        dfs_u(0, -1);

        vector<int> res;
        for (int i = 0; i < n; ++ i ) {
            int x = v[i];
            res.push_back(f[i] + g[i] - x);
        }
        return res;
    }
};
```
