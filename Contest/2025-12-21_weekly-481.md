# 第 481 场周赛

链接: https://leetcode.cn/contest/weekly-contest-481/

---

### [3783. Mirror Distance of an Integer](https://leetcode.cn/problems/mirror-distance-of-an-integer/)

```c++
class Solution {
public:
    int get(int x) {
        int ret = 0;
        while (x) {
            ret = ret * 10 + x % 10;
            x /= 10;
        }
        return ret;
    }
    
    int mirrorDistance(int n) {
        int rn = get(n);
        return abs(n - rn);
    }
};
```

### [3784. Minimum Deletion Cost to Make All Characters Equal](https://leetcode.cn/problems/minimum-deletion-cost-to-make-all-characters-equal/)

```c++
class Solution {
public:
    using LL = long long;
    
    long long minCost(string s, vector<int>& cost) {
        LL tot[26], sum = 0;
        for (int i = 0; i < s.size(); ++ i )
            tot[s[i] - 'a'] += cost[i], sum += cost[i];
        
        LL res = 0;
        for (int i = 0; i < 26; ++ i )
            res = max(res, tot[i]);
        return sum - res;
    }
};
```

### [3785. Minimum Swaps to Avoid Forbidden Values](https://leetcode.cn/problems/minimum-swaps-to-avoid-forbidden-values/)

```c++
// 类似题目
//  leetcode 2141. 同时运行 N 台电脑的最长时间
//  leetcode 2335. 装满杯子需要的最短总时长
//  leetcode 3139. 使数组中所有元素相等的最小开销
//  leetcode 3495. 使数组元素都变为零的最少操作次数
//  leetcode 3664. 两个字母卡牌游戏

class Solution {
public:
    int minSwaps(vector<int>& nums, vector<int>& forbidden) {
        int n = nums.size();

        // 考虑无解情况
        // 假定排列为 2xn 矩阵，如果某个数字上下出现总次数超过 n 则必定有一列重复，则无解
        unordered_map<int, int> tot;
        for (auto x : nums)
            tot[x] ++ ;
        for (auto x : forbidden) {
            tot[x] ++ ;
            if (tot[x] > n)
                return -1;
        }
        
        // 接下来考虑通过交换来消除重复列
        // 1. 对于不同的两个重复列，交换一次可以将两列变为非重复列
        // 2. 对于单个重复列，必然需要上下行都不等于它的另外一个列交换【必然存在，反证】
        //
        // 将重复列以其数字表示，模型转化为：
        // 给定数组 xs，每次最多删除其中两个元素，求总删除次数
        // res = max((len + 1) / 2, max_count)
        unordered_map<int, int> cnt;
        int len = 0, max_count = 0;
        for (int i = 0; i < n; ++ i ) {
            if (nums[i] != forbidden[i])
                continue;
            len ++ ;
            max_count = max(max_count, ++ cnt[nums[i]]);
        }
        return max((len + 1) / 2, max_count);
    }
};
```

### [3786. Total Sum of Interaction Cost in Tree Groups](https://leetcode.cn/problems/total-sum-of-interaction-cost-in-tree-groups/)

```c++
// 放里面 TLE
using LL = long long;
const static int N = 1e5 + 10, M = 2e5 + 10, K = 21;

int h[N], e[M], ne[M], idx;
void init() {
    memset(h, -1, sizeof h);
    idx = 0;
}
void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

LL s[K];
LL sz[N][K], d[N][K];

class Solution {
public:
    vector<int> gs;

    void dfs(int u, int fa) {
        int g = gs[u];
        sz[u][g] = 1, d[u][g] = 0;
        LL sum = 0;
        for (int i = h[u]; ~i; i = ne[i]) {
            int j = e[i];
            if (j == fa)
                continue;

            dfs(j, u);

            // 考虑清楚，新增一颗子树时带来的增量，分两个部分单独统计，然后叠加一条边长的数量
            // 两侧分别认为是独立的多条带权线
            for (int k = 0; k < K; ++ k )
                sum += sz[u][k] * d[j][k] + sz[j][k] * d[u][k] + sz[u][k] * sz[j][k];

            for (int k = 0; k < K; ++ k )
                sz[u][k] += sz[j][k], d[u][k] += sz[j][k] + d[j][k];    // overflow, use LL
        }
        s[g] += sum;
    }
    
    long long interactionCosts(int n, vector<vector<int>>& edges, vector<int>& group) {
        init();
        for (auto & e : edges)
            add(e[0], e[1]), add(e[1], e[0]);

        this->gs = group;

        memset(s, 0, sizeof s);
        memset(sz, 0, sizeof sz), memset(d, 0, sizeof d);
        dfs(0, -1);

        LL res = 0;
        for (int i = 0; i < K; ++ i )
            res += s[i];
        return res;
    }
};
```

还有个思路，更清晰。计算边的贡献

```c++
class Solution {
public:
    using LL = long long;
    const static int N = 1e5 + 10, M = 2e5 + 10, K = 21;

    int h[N], e[M], ne[M], idx;
    void init() {
        memset(h, -1, sizeof h);
        idx = 0;
    }
    void add(int a, int b) {
        e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
    }

    vector<int> gs;
    unordered_map<int, int> tot;

    int cnt[N][K];
    LL res;

    void dfs(int u, int fa) {
        int g = gs[u];
        cnt[u][g] = 1;
        for (int i = h[u]; ~i; i = ne[i]) {
            int j = e[i];
            if (j == fa)
                continue;

            dfs(j, u);

            for (int k = 0; k < K; ++ k ) {
                // 计算 u->j 这一条边的贡献 【包括从这一条边向上的路径，所以需要提前计算总量tot】
                res += 1ll * cnt[j][k] * (tot[k] - cnt[j][k]);
                cnt[u][k] += cnt[j][k];
            }
        }
    }
    
    long long interactionCosts(int n, vector<vector<int>>& edges, vector<int>& group) {
        init();
        for (auto & e : edges)
            add(e[0], e[1]), add(e[1], e[0]);

        this->gs = group;
        tot.clear();
        for (auto x : gs)
            tot[x] ++ ;

        memset(cnt, 0, sizeof cnt);
        res = 0;

        dfs(0, -1);
        return res;
    }
};
```